#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Unit tests for the maf_parser module.

These tests verify that the MAFParser class functions correctly,
including parsing MAF files, identifying conserved regions,
generating coordinate maps, and masking sequences.
"""

import os
import pytest
import tempfile
from unittest.mock import patch, MagicMock, mock_open, call
from io import StringIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord

from ...helpers import MAFParser
from ...config import Config, AlignmentError


# Sample MAF data for testing
SAMPLE_MAF_DATA = """##maf version=1 scoring=lastz
# generated by lastz

a score=54321
s chr1        100 50 + 1000 ATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCAT
s scaffold1   200 50 + 2000 ATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCAT

a score=12345
s chr1        200 60 + 1000 CGTATAGCTAGCTAGCTAGCTACGATCGATCGATCGATCGATCGACTACGTACGT
s scaffold1   300 60 - 2000 CGTATAGCTAGCTAGCTAGCTACGATCGATCGATCGATCGATCGACTACGTACGT

a score=98765
s chr2        50  40 + 800  ATATATATATATATATATATATATATATATATATATATATAT
s scaffold2   100 40 + 1500 ATATATATATAT-TATATATATATATATATATA-ATATATAT
"""


# Fixtures
@pytest.fixture
def maf_parser():
    """Create a MAFParser instance for testing."""
    return MAFParser()


@pytest.fixture
def mock_config():
    """Create a mock Config object."""
    config = MagicMock()
    config.MIN_IDENTITY = 80
    config.MIN_SEGMENT_LENGTH = 20
    config.SHOW_PROGRESS = False
    return config


@pytest.fixture
def temp_maf_file():
    """Create a temporary MAF file for testing."""
    with tempfile.NamedTemporaryFile(mode='w+', delete=False) as temp_file:
        temp_file.write(SAMPLE_MAF_DATA)
        temp_file_path = temp_file.name
    
    yield temp_file_path
    
    # Clean up
    if os.path.exists(temp_file_path):
        os.unlink(temp_file_path)


# Test parse_maf_file
def test_parse_maf_file_success(maf_parser, temp_maf_file):
    """Test successful parsing of a MAF file."""
    # Call the function
    result = maf_parser.parse_maf_file(temp_maf_file)
    
    # Verify the result
    assert isinstance(result, dict)
    assert "chr1" in result
    assert "chr2" in result
    assert len(result["chr1"]) == 2  # Two alignments for chr1
    assert len(result["chr2"]) == 1  # One alignment for chr2
    
    # Check alignment details
    alignment = result["chr1"][0]
    assert alignment["ref_chrom"] == "chr1"
    assert alignment["ref_start"] == 100
    assert alignment["ref_end"] == 150  # 100 + 50
    assert alignment["qry_src"] == "scaffold1"
    assert alignment["qry_start"] == 200
    assert alignment["qry_end"] == 250  # 200 + 50
    assert alignment["identity"] > 0


def test_parse_maf_file_nonexistent(maf_parser):
    """Test error handling for nonexistent MAF file."""
    with pytest.raises(AlignmentError, match="MAF file not found"):
        maf_parser.parse_maf_file("/nonexistent/file.maf")


@patch('os.path.exists', return_value=True)  # Mock os.path.exists to return True
@patch('builtins.open', new_callable=mock_open)
def test_parse_maf_file_error(mock_file, mock_exists, maf_parser):
    """Test error handling during MAF file parsing."""
    # Setup mock to raise an exception
    mock_file.side_effect = Exception("File reading error")
    
    # Call the function and verify it raises the expected exception
    with pytest.raises(AlignmentError, match="Failed to parse MAF file"):
        maf_parser.parse_maf_file("test.maf")


# Test _process_alignment_block
def test_process_alignment_block(maf_parser):
    """Test processing of a single alignment block."""
    # Setup test data
    alignment_lines = [
        "a score=54321",
        "s chr1        100 50 + 1000 ATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCAT",
        "s scaffold1   200 50 + 2000 ATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCAT"
    ]
    
    # Call the function
    maf_parser._process_alignment_block(alignment_lines)
    
    # Verify the result
    assert "chr1" in maf_parser.alignments
    assert len(maf_parser.alignments["chr1"]) == 1
    
    alignment = maf_parser.alignments["chr1"][0]
    assert alignment["ref_chrom"] == "chr1"
    assert alignment["ref_start"] == 100
    assert alignment["ref_end"] == 150
    assert alignment["qry_src"] == "scaffold1"
    assert alignment["qry_start"] == 200
    assert alignment["qry_end"] == 250
    assert alignment["identity"] == 100.0  # Identical sequences


def test_process_alignment_block_with_gaps(maf_parser):
    """Test processing of an alignment block with gaps."""
    # Setup test data with gaps and mismatches to ensure identity < 100%
    alignment_lines = [
        "a score=98765",
        "s chr2        50  40 + 800  ATATATATATATATATATATATATATATATATATATATATAT",
        "s scaffold2   100 40 + 1500 ATATATAT-TATATATATAGACATATATATAT-ATATATAT"  # Added mismatches
    ]
    
    # Call the function
    maf_parser._process_alignment_block(alignment_lines)
    
    # Verify the result
    assert "chr2" in maf_parser.alignments
    alignment = maf_parser.alignments["chr2"][0]
    
    # Identity should be less than 100% due to gaps and mismatches
    assert alignment["identity"] < 100.0


def test_process_alignment_block_incomplete(maf_parser):
    """Test handling of incomplete alignment blocks."""
    # Test with just a header (no sequences)
    maf_parser._process_alignment_block(["a score=123"])
    assert len(maf_parser.alignments) == 0
    
    # Test with just one sequence
    maf_parser._process_alignment_block([
        "a score=123",
        "s chr1 100 50 + 1000 ATGCATGCATGC"
    ])
    assert len(maf_parser.alignments) == 0


# Test _calculate_identity
def test_calculate_identity_identical(maf_parser):
    """Test identity calculation for identical sequences."""
    seq1 = "ATGCATGCATGC"
    seq2 = "ATGCATGCATGC"
    
    result = maf_parser._calculate_identity(seq1, seq2)
    assert result == 100.0


def test_calculate_identity_with_mismatches(maf_parser):
    """Test identity calculation with mismatches."""
    seq1 = "ATGCATGCATGC"
    seq2 = "ATGCATGTATGC"  # One mismatch (G -> T)
    
    result = maf_parser._calculate_identity(seq1, seq2)
    
    # Use approximate equality to handle floating point precision issues
    expected = 91.66666666666667  # 11/12 * 100
    assert abs(result - expected) < 0.000001  # Allow for small floating point differences



def test_calculate_identity_with_gaps(maf_parser):
    """Test identity calculation with gaps."""
    seq1 = "ATGCATGCATGC"
    seq2 = "ATGC-TGCATGC"  # One gap
    
    result = maf_parser._calculate_identity(seq1, seq2)
    assert result == 100.0  # Only comparing non-gap positions


def test_calculate_identity_all_gaps(maf_parser):
    """Test identity calculation when all positions have gaps."""
    seq1 = "----"
    seq2 = "----"
    
    result = maf_parser._calculate_identity(seq1, seq2)
    assert result == 0.0  # No valid positions to compare


# Test identify_conserved_regions
def test_identify_conserved_regions_no_alignments(maf_parser):
    """Test error handling when no alignments are loaded."""
    with pytest.raises(AlignmentError, match="No alignments loaded"):
        maf_parser.identify_conserved_regions()


def test_identify_conserved_regions_success(maf_parser, temp_maf_file):
    """Test successful identification of conserved regions."""
    # First parse a MAF file
    maf_parser.parse_maf_file(temp_maf_file)
    
    # Call the function
    result = maf_parser.identify_conserved_regions(min_identity=80, min_length=20)
    
    # Verify the result
    assert isinstance(result, dict)
    assert "chr1" in result
    assert "chr2" in result
    
    # Check conserved regions for chr1
    assert len(result["chr1"]) > 0
    region = result["chr1"][0]
    assert "start" in region
    assert "end" in region
    assert "identity" in region
    assert "qry_src" in region
    assert "qry_start" in region
    assert "qry_end" in region
    assert "qry_strand" in region


@patch('ddprimer.helpers.maf_parser.MAFParser._find_conserved_blocks')
def test_identify_conserved_regions_error(mock_find_blocks, maf_parser, temp_maf_file):
    """Test error handling during conserved region identification."""
    # First parse a MAF file
    maf_parser.parse_maf_file(temp_maf_file)
    
    # Setup mock to raise an exception
    mock_find_blocks.side_effect = Exception("Block finding error")
    
    # Call the function and verify it raises the expected exception
    with pytest.raises(AlignmentError, match="Failed to identify conserved regions"):
        maf_parser.identify_conserved_regions()


# Test _find_conserved_blocks
def test_find_conserved_blocks_identical(maf_parser):
    """Test finding conserved blocks in identical sequences."""
    ref_seq = "ATGCATGCATGCATGCATGCATGC"
    qry_seq = "ATGCATGCATGCATGCATGCATGC"
    ref_start = 100
    min_length = 20
    
    blocks = maf_parser._find_conserved_blocks(ref_seq, qry_seq, ref_start, min_length)
    
    assert len(blocks) == 1
    assert blocks[0]["start"] == 100
    assert blocks[0]["end"] == 123  # 100 + 24 - 1
    assert blocks[0]["identity"] == 100.0


def test_find_conserved_blocks_with_gaps(maf_parser):
    """Test finding conserved blocks with gaps in sequences."""
    ref_seq = "ATGCATGCATGC--ATGCATGCATGC"
    qry_seq = "ATGCATGCATGCAT--GCATGCATGC"
    ref_start = 100
    min_length = 10
    
    blocks = maf_parser._find_conserved_blocks(ref_seq, qry_seq, ref_start, min_length)
    
    # Should find two blocks (before and after the gaps)
    assert len(blocks) == 2


def test_find_conserved_blocks_too_short(maf_parser):
    """Test handling of blocks that are too short."""
    ref_seq = "ATGC--ATGC"  # Two short segments
    qry_seq = "ATGCAT--GC"
    ref_start = 100
    min_length = 5  # Longer than each segment
    
    blocks = maf_parser._find_conserved_blocks(ref_seq, qry_seq, ref_start, min_length)
    
    # No blocks should meet the minimum length
    assert len(blocks) == 0


# Test _map_to_query_coords
def test_map_to_query_coords_identical(maf_parser):
    """Test coordinate mapping with identical sequences."""
    ref_seq = "ATGCATGCATGC"
    qry_seq = "ATGCATGCATGC"
    ref_offset = 5  # Position of the 6th base (0-indexed)
    qry_start = 100
    
    result = maf_parser._map_to_query_coords(ref_offset, ref_seq, qry_seq, qry_start)
    
    # With identical sequences, qry_pos = qry_start + ref_offset
    assert result == 105


def test_map_to_query_coords_with_gaps(maf_parser):
    """Test coordinate mapping with gaps in sequences."""
    ref_seq = "ATGC--ATGC"
    qry_seq = "ATGCAT--GC"
    ref_offset = 6  # Position after the gap in ref_seq
    qry_start = 100
    
    result = maf_parser._map_to_query_coords(ref_offset, ref_seq, qry_seq, qry_start)
    
    # With gaps, the mapping is more complex
    assert result == 106  # qry_start + 6 (accounting for the 2-base gap in qry_seq)


def test_map_to_query_coords_beyond_end(maf_parser):
    """Test coordinate mapping when offset is beyond sequence length."""
    ref_seq = "ATGC"
    qry_seq = "ATGC"
    ref_offset = 10  # Beyond the sequence length
    qry_start = 100
    
    result = maf_parser._map_to_query_coords(ref_offset, ref_seq, qry_seq, qry_start)
    
    # Should return the last position + 1
    assert result == 104  # qry_start + len(qry_seq without gaps)


# Test extract_reference_sequences_from_maf
def test_extract_reference_sequences_no_alignments(maf_parser):
    """Test error handling when no alignments are loaded."""
    with pytest.raises(AlignmentError, match="No alignments loaded"):
        maf_parser.extract_reference_sequences_from_maf()


def test_extract_reference_sequences_success(maf_parser, temp_maf_file):
    """Test successful extraction of reference sequences from MAF."""
    # First parse a MAF file
    maf_parser.parse_maf_file(temp_maf_file)
    
    # Call the function
    result = maf_parser.extract_reference_sequences_from_maf()
    
    # Verify the result
    assert isinstance(result, dict)
    assert "chr1" in result
    assert "chr2" in result
    
    # Check sequence lengths
    assert len(result["chr1"]) >= 260  # Based on the test data (start + length of second alignment)
    assert len(result["chr2"]) >= 90   # Based on the test data


def test_extract_reference_sequences_contains_expected_data(maf_parser, temp_maf_file):
    """Test that extract_reference_sequences_from_maf returns expected data."""
    # Parse a MAF file
    maf_parser.parse_maf_file(temp_maf_file)
    
    # Call the function
    result = maf_parser.extract_reference_sequences_from_maf()
    
    # Basic validation of the result
    assert isinstance(result, dict)
    assert len(result) > 0
    # Check that it contains the sequences we expect from the sample data
    assert "chr1" in result
    assert "chr2" in result


@patch('ddprimer.helpers.maf_parser.MAFParser.extract_reference_sequences_from_maf')
def test_extract_reference_sequences_handles_errors(mock_extract, maf_parser):
    """Test that extract_reference_sequences_from_maf properly handles errors."""
    # Configure the mock to raise an AlignmentError
    mock_extract.side_effect = AlignmentError("Failed to extract reference sequences")
    
    # Call the function and verify it raises the expected exception
    with pytest.raises(AlignmentError, match="Failed to extract reference sequences"):
        # Call the mocked function through the instance
        maf_parser.extract_reference_sequences_from_maf()


@patch('ddprimer.helpers.maf_parser.MAFParser._load_input_sequences')
def test_mask_non_conserved_regions_input_file(mock_load_sequences, maf_parser, temp_maf_file):
    """Test masking with input file instead of sequence dictionary."""
    # Setup mock to return sequences
    mock_load_sequences.return_value = {
        "chr1": "A" * 1000,
        "chr2": "G" * 800
    }
    
    # First parse a MAF file and identify conserved regions
    maf_parser.parse_maf_file(temp_maf_file)
    conserved_regions = maf_parser.identify_conserved_regions()
    
    # Use a temporary file for masked output
    with tempfile.NamedTemporaryFile(suffix='.fasta') as temp_out:
        # Call the function with a file path instead of sequences
        with patch('ddprimer.helpers.maf_parser.SeqIO.write'):
            maf_parser.mask_non_conserved_regions(
                "input.fasta", temp_out.name, conserved_regions, min_identity=80
            )
    
    # Verify sequences were loaded from file
    mock_load_sequences.assert_called_once_with("input.fasta")


@patch('ddprimer.helpers.maf_parser.MAFParser._load_input_sequences')
def test_mask_non_conserved_regions_error(mock_load_sequences, maf_parser, temp_maf_file):
    """Test error handling during masking."""
    # Setup mock to raise an exception
    mock_load_sequences.side_effect = Exception("Failed to load sequences")
    
    # First parse a MAF file and identify conserved regions
    maf_parser.parse_maf_file(temp_maf_file)
    conserved_regions = maf_parser.identify_conserved_regions()
    
    # Call the function and verify it raises the expected exception
    with pytest.raises(AlignmentError, match="Failed to mask non-conserved regions"):
        maf_parser.mask_non_conserved_regions(
            "input.fasta", "output.fasta", conserved_regions
        )


# Test _load_input_sequences
@patch('ddprimer.helpers.maf_parser.SeqIO.parse')
def test_load_input_sequences_from_file(mock_seqio_parse, maf_parser):
    """Test loading sequences from a FASTA file."""
    # Setup mock sequences
    mock_seqio_parse.return_value = [
        SeqRecord(Seq("ATGC"), id="seq1"),
        SeqRecord(Seq("GCTA"), id="seq2")
    ]
    
    # Call the function
    result = maf_parser._load_input_sequences("input.fasta")
    
    # Verify the result
    assert isinstance(result, dict)
    assert "seq1" in result
    assert "seq2" in result
    assert result["seq1"] == "ATGC"
    assert result["seq2"] == "GCTA"


def test_load_input_sequences_from_dict(maf_parser):
    """Test using an existing sequence dictionary."""
    sequences = {
        "seq1": "ATGC",
        "seq2": "GCTA"
    }
    
    # Call the function
    result = maf_parser._load_input_sequences(sequences)
    
    # Verify the result is the same dictionary
    assert result is sequences


# Test _apply_region_masks
def test_apply_region_masks_success(maf_parser):
    """Test successful application of region masks."""
    # Setup test data
    sequences = {
        "chr1": "ATGCATGCATGC",
        "chr2": "GCTAGCTAGCTA"
    }
    
    masks = {
        "chr1": [0] * 12,
        "chr2": [0] * 12
    }
    
    reverse_map = {
        "chr1": ["contig1"],
        "chr2": ["contig2"]
    }
    
    conserved_regions = {
        "contig1": [
            {"start": 2, "end": 5, "identity": 90.0}
        ],
        "contig2": [
            {"start": 3, "end": 8, "identity": 95.0}
        ]
    }
    
    # Call the function
    masked_records, stats = maf_parser._apply_region_masks(
        sequences, masks, reverse_map, conserved_regions, min_identity=80
    )
    
    # Verify the result
    assert len(masked_records) == 2
    assert stats["applied_regions"] == 2
    assert stats["total_regions"] == 2
    
    # chr1 should have positions 2-5 unmasked (4 bases)
    assert masks["chr1"].count(1) == 4
    # chr2 should have positions 3-8 unmasked (6 bases)
    assert masks["chr2"].count(1) == 6


def test_apply_region_masks_no_mapping(maf_parser):
    """Test handling when there's no mapping between FASTA and alignment sequences."""
    # Setup test data
    sequences = {
        "chr1": "ATGCATGCATGC",
        "unmapped": "GCTAGCTAGCTA"  # This sequence has no mapping
    }
    
    masks = {
        "chr1": [0] * 12,
        "unmapped": [0] * 12
    }
    
    reverse_map = {
        "chr1": ["contig1"]
        # No mapping for "unmapped"
    }
    
    conserved_regions = {
        "contig1": [
            {"start": 2, "end": 5, "identity": 90.0}
        ]
    }
    
    # Call the function
    masked_records, stats = maf_parser._apply_region_masks(
        sequences, masks, reverse_map, conserved_regions, min_identity=80
    )
    
    # Verify the result
    assert len(masked_records) == 2
    assert stats["applied_regions"] == 1
    assert stats["total_regions"] == 1
    
    # chr1 should have some unmasked positions
    assert masks["chr1"].count(1) > 0
    # "unmapped" should remain fully masked
    assert masks["unmapped"].count(1) == 0


# Test generate_coordinate_map
def test_generate_coordinate_map_success(maf_parser, temp_maf_file):
    """Test successful generation of coordinate map."""
    # First parse a MAF file and identify conserved regions
    maf_parser.parse_maf_file(temp_maf_file)
    conserved_regions = maf_parser.identify_conserved_regions()
    
    # Call the function
    result = maf_parser.generate_coordinate_map(conserved_regions)
    
    # Verify the result
    assert isinstance(result, dict)
    assert "chr1" in result
    assert "chr2" in result
    
    # Check coordinate mappings
    assert len(result["chr1"]) > 0
    assert len(result["chr2"]) > 0
    
    # Check a specific position's mapping
    position_map = next(iter(result["chr1"].values()))
    assert "qry_src" in position_map
    assert "qry_pos" in position_map
    assert "qry_strand" in position_map


def test_generate_coordinate_map_with_reverse_strand(maf_parser):
    """Test coordinate mapping with reverse strand alignments."""
    # Setup test conserved regions with reverse strand
    conserved_regions = {
        "chr1": [
            {
                "start": 100,
                "end": 200,
                "qry_src": "scaffold1",
                "qry_start": 300,
                "qry_end": 400,
                "qry_strand": "-"  # Reverse strand
            }
        ]
    }
    
    # Call the function
    result = maf_parser.generate_coordinate_map(conserved_regions)
    
    # Verify the mapping has correct strand information
    assert "chr1" in result
    position_map = result["chr1"][100]  # First position in the region
    assert position_map["qry_strand"] == "-"
    
    # Check that positions are correctly reversed
    # In reverse strand mapping, the first position in reference (100)
    # should map to the last position in query (400)
    assert position_map["qry_pos"] == 400


# Test map_second_variants_to_reference
def test_map_second_variants_to_reference_success(maf_parser):
    """Test successful mapping of second genome variants to reference."""
    # Setup test data
    second_variants = {
        "scaffold1": {350, 360},
        "scaffold2": {150}
    }
    
    coordinate_map = {
        "chr1": {
            100: {"qry_src": "scaffold1", "qry_pos": 350, "qry_strand": "+"},
            110: {"qry_src": "scaffold1", "qry_pos": 360, "qry_strand": "+"}
        },
        "chr2": {
            50: {"qry_src": "scaffold2", "qry_pos": 150, "qry_strand": "+"}
        }
    }
    
    # Call the function
    result = maf_parser.map_second_variants_to_reference(second_variants, coordinate_map)
    
    # Verify the result
    assert isinstance(result, dict)
    assert "chr1" in result
    assert "chr2" in result
    assert result["chr1"] == {100, 110}
    assert result["chr2"] == {50}


def test_map_second_variants_to_reference_no_mapping(maf_parser):
    """Test handling when there's no mapping for some variants."""
    # Setup test data
    second_variants = {
        "scaffold1": {350, 360},
        "unmapped": {200}  # This scaffold has no mapping
    }
    
    coordinate_map = {
        "chr1": {
            100: {"qry_src": "scaffold1", "qry_pos": 350, "qry_strand": "+"},
            110: {"qry_src": "scaffold1", "qry_pos": 360, "qry_strand": "+"}
        }
    }
    
    # Call the function
    result = maf_parser.map_second_variants_to_reference(second_variants, coordinate_map)
    
    # Verify the result
    assert "chr1" in result
    assert result["chr1"] == {100, 110}
    # No mapping for "unmapped" scaffold


@patch('ddprimer.helpers.maf_parser.MAFParser._create_reverse_coordinate_map')
def test_map_second_variants_to_reference_error(mock_create_map, maf_parser):
    """Test error handling during variant mapping."""
    # Setup mock to raise an exception
    mock_create_map.side_effect = Exception("Mapping creation failed")
    
    # Call the function and verify it raises the expected exception
    with pytest.raises(AlignmentError, match="Failed to map second genome variants"):
        maf_parser.map_second_variants_to_reference({}, {})


# Test _create_reverse_coordinate_map
def test_create_reverse_coordinate_map(maf_parser):
    """Test creation of reverse coordinate map."""
    # Setup test data
    coordinate_map = {
        "chr1": {
            100: {"qry_src": "scaffold1", "qry_pos": 350, "qry_strand": "+"},
            110: {"qry_src": "scaffold1", "qry_pos": 360, "qry_strand": "+"}
        },
        "chr2": {
            50: {"qry_src": "scaffold2", "qry_pos": 150, "qry_strand": "-"}
        }
    }
    
    # Call the function
    result = maf_parser._create_reverse_coordinate_map(coordinate_map)
    
    # Verify the result
    assert isinstance(result, dict)
    assert "scaffold1" in result
    assert "scaffold2" in result
    
    # Check scaffold1 mappings
    assert 350 in result["scaffold1"]
    assert 360 in result["scaffold1"]
    assert result["scaffold1"][350]["ref_chrom"] == "chr1"
    assert result["scaffold1"][350]["ref_pos"] == 100
    
# Check scaffold2 mappings
    assert 150 in result["scaffold2"]
    assert result["scaffold2"][150]["ref_chrom"] == "chr2"
    assert result["scaffold2"][150]["ref_pos"] == 50
    assert result["scaffold2"][150]["strand"] == "-"


# Test analyze_maf_file
def test_analyze_maf_file_success(maf_parser, temp_maf_file):
    """Test successful analysis of MAF file structure."""
    # Call the function
    result = maf_parser.analyze_maf_file(temp_maf_file)
    
    # Verify the result
    assert isinstance(result, dict)
    assert "alignment_count" in result
    assert "seq_ids" in result
    assert "ref_seq_ids" in result
    assert "query_seq_ids" in result
    
    # Check specific values
    assert result["alignment_count"] == 3  # From the test data
    assert "chr1" in result["ref_seq_ids"]
    assert "chr2" in result["ref_seq_ids"]
    assert "scaffold1" in result["query_seq_ids"]
    assert "scaffold2" in result["query_seq_ids"]


def test_analyze_maf_file_nonexistent(maf_parser):
    """Test error handling for nonexistent MAF file."""
    with pytest.raises(AlignmentError, match="MAF file not found"):
        maf_parser.analyze_maf_file("/nonexistent/file.maf")


@patch('os.path.exists', return_value=True)  # Mock os.path.exists to return True
@patch('builtins.open', new_callable=mock_open)
def test_analyze_maf_file_error(mock_file, mock_exists, maf_parser):
    """Test error handling during MAF file analysis."""
    # Setup mock to raise an exception
    mock_file.side_effect = Exception("File reading error")
    
    # Call the function and verify it raises the expected exception
    with pytest.raises(AlignmentError, match="MAF file analysis failed"):
        maf_parser.analyze_maf_file("test.maf")


# Test _map_chromosomes
def test_map_chromosomes_direct_match(maf_parser):
    """Test chromosome mapping with direct matches."""
    align_chroms = ["chr1", "chr2", "chr3"]
    fasta_ids = ["chr1", "chr2", "chr3", "chr4"]
    
    result = maf_parser._map_chromosomes(align_chroms, fasta_ids)
    
    # Verify the result
    assert len(result) == 3
    assert result["chr1"] == "chr1"
    assert result["chr2"] == "chr2"
    assert result["chr3"] == "chr3"


def test_map_chromosomes_contained_match(maf_parser):
    """Test chromosome mapping with contained matches."""
    align_chroms = ["1", "2", "X"]
    fasta_ids = ["chr1", "chr2", "chrX", "chr4"]
    
    result = maf_parser._map_chromosomes(align_chroms, fasta_ids)
    
    # Verify the result
    assert len(result) >= 3
    assert result["1"] == "chr1"
    assert result["2"] == "chr2"
    assert result["X"] == "chrX"


def test_map_chromosomes_numeric_match(maf_parser):
    """Test chromosome mapping with numeric matches."""
    align_chroms = ["1", "2", "3"]
    fasta_ids = ["Chr1", "Chr2", "chr3_modified", "scaffold_4"]
    
    result = maf_parser._map_chromosomes(align_chroms, fasta_ids)
    
    # Verify the result
    assert len(result) >= 3
    assert result["1"] == "Chr1"
    assert result["2"] == "Chr2"
    assert result["3"] == "chr3_modified"


def test_map_chromosomes_fallback_mapping(maf_parser):
    """Test chromosome mapping with fallback positional mapping."""
    align_chroms = ["unknown1", "unknown2"]
    fasta_ids = ["chr1", "chr2"]
    
    result = maf_parser._map_chromosomes(align_chroms, fasta_ids)
    
    # When no direct matches are found but sizes match, it should use positional mapping
    assert len(result) == 2
    assert "unknown1" in result
    assert "unknown2" in result


if __name__ == "__main__":
    pytest.main(["-v"])